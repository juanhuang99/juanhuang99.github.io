{"meta":{"title":"Juan's Home","subtitle":"Be yourself, and be the person you hope to be","description":null,"author":"吃葡萄不吐番茄皮","url":"https://juanhuang99.github.io"},"pages":[{"title":"","date":"2021-10-29T07:39:40.997Z","updated":"2018-07-17T05:25:55.000Z","comments":true,"path":"README.html","permalink":"https://juanhuang99.github.io/README.html","excerpt":"","text":"博客访问地址 点击"},{"title":"","date":"2021-10-29T07:39:40.994Z","updated":"2018-07-17T01:46:01.000Z","comments":true,"path":"404.html","permalink":"https://juanhuang99.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-11-03T07:40:43.489Z","updated":"2021-11-03T07:40:43.489Z","comments":true,"path":"nextConfig.json","permalink":"https://juanhuang99.github.io/nextConfig.json","excerpt":"","text":"{\"override\":false,\"favicon\":{\"small\":\"/images/favicon-16x16-next.png\",\"medium\":\"/images/favicon-32x32-next.png\",\"apple_touch_icon\":\"/images/apple-touch-icon-next.png\",\"safari_pinned_tab\":\"/images/logo.svg\"},\"keywords\":\"Hexo, NexT\",\"rss\":false,\"footer\":{\"icon\":\"user\",\"copyright\":null,\"powered\":false,\"theme\":{\"enable\":false,\"version\":false}},\"canonical\":true,\"seo\":false,\"index_with_subtitle\":false,\"menu\":{\"home\":\"/ || home\",\"categories\":\"/categories/ || th\",\"archives\":\"/archives/ || archive\",\"tags\":\"/tags/ || tags\"},\"menu_icons\":{\"enable\":true},\"title\":\"吃葡萄不吐番茄皮\",\"subtitle\":\"Be yourself, and be the person you hope to be\",\"avatar\":\"/images/personal-avatar.jpg\",\"author\":\"吃葡萄不吐番茄皮\",\"description\":\"心有猛虎 轻嗅蔷薇\",\"scheme\":\"Mist\",\"social_icons\":{\"enable\":true,\"icons_only\":false,\"transition\":false},\"links_icon\":\"link\",\"links_title\":\"Links\",\"links_layout\":\"block\",\"toc\":{\"enable\":true,\"number\":true,\"wrap\":false},\"sidebar\":{\"position\":\"left\",\"display\":\"post\",\"offset\":12,\"b2t\":false,\"scrollpercent\":false,\"onmobile\":false},\"scroll_to_more\":true,\"save_scroll\":false,\"excerpt_description\":true,\"auto_excerpt\":{\"enable\":false,\"length\":150},\"post_meta\":{\"item_text\":true,\"created_at\":true,\"updated_at\":false,\"categories\":true},\"post_wordcount\":{\"item_text\":true,\"wordcount\":false,\"min2read\":false,\"totalcount\":false,\"separated_meta\":true},\"post_copyright\":{\"enable\":false,\"license\":\"CC BY-NC-SA 3.0\",\"license_url\":\"https://creativecommons.org/licenses/by-nc-sa/3.0/\"},\"mobile_layout_economy\":false,\"android_chrome_color\":\"#222\",\"custom_logo\":{\"enabled\":false,\"image\":null},\"highlight_theme\":\"normal\",\"font\":{\"enable\":false,\"host\":null,\"global\":{\"external\":true,\"family\":\"Lato\",\"size\":null},\"headings\":{\"external\":true,\"family\":null,\"size\":null},\"posts\":{\"external\":true,\"family\":null},\"logo\":{\"external\":true,\"family\":null,\"size\":null},\"codes\":{\"external\":true,\"family\":null,\"size\":null}},\"mathjax\":{\"enable\":false,\"per_page\":false,\"cdn\":\"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML\"},\"han\":false,\"disqus\":{\"enable\":false,\"shortname\":null,\"count\":true},\"changyan\":{\"enable\":false,\"appid\":null,\"appkey\":null},\"valine\":{\"enable\":false,\"appid\":null,\"appkey\":null,\"notify\":false,\"verify\":false,\"placeholder\":\"Just go go\",\"avatar\":\"mm\",\"guest_info\":\"nick,mail,link\",\"pageSize\":10},\"gitment\":{\"enable\":false,\"mint\":true,\"count\":true,\"lazy\":false,\"cleanly\":false,\"language\":null,\"github_user\":null,\"github_repo\":null,\"client_id\":null,\"client_secret\":null,\"proxy_gateway\":null,\"redirect_protocol\":null},\"needmoreshare2\":{\"enable\":false,\"postbottom\":{\"enable\":false,\"options\":{\"iconStyle\":\"box\",\"boxForm\":\"horizontal\",\"position\":\"bottomCenter\",\"networks\":\"Weibo,Wechat,Douban,QQZone,Twitter,Facebook\"}},\"float\":{\"enable\":false,\"options\":{\"iconStyle\":\"box\",\"boxForm\":\"horizontal\",\"position\":\"middleRight\",\"networks\":\"Weibo,Wechat,Douban,QQZone,Twitter,Facebook\"}}},\"duoshuo_info\":{\"ua_enable\":true,\"admin_enable\":false,\"user_id\":0},\"facebook_sdk\":{\"enable\":false,\"app_id\":null,\"fb_admin\":null,\"like_button\":null,\"webmaster\":null},\"facebook_comments_plugin\":{\"enable\":false,\"num_of_posts\":10,\"width\":\"100%\",\"scheme\":\"light\"},\"vkontakte_api\":{\"enable\":false,\"app_id\":null,\"like\":true,\"comments\":true,\"num_of_posts\":10},\"rating\":{\"enable\":false,\"id\":null,\"color\":\"fc6423\"},\"leancloud_visitors\":{\"enable\":false,\"app_id\":null,\"app_key\":null},\"firestore\":{\"enable\":false,\"collection\":\"articles\",\"apiKey\":null,\"projectId\":null,\"bluebird\":false},\"busuanzi_count\":{\"enable\":false,\"site_uv\":true,\"site_uv_header\":\"\",\"site_uv_footer\":null,\"site_pv\":true,\"site_pv_header\":\"\",\"site_pv_footer\":null,\"page_pv\":true,\"page_pv_header\":\"\",\"page_pv_footer\":null},\"baidu_push\":false,\"calendar\":{\"enable\":false,\"calendar_id\":\"\",\"api_key\":\"\",\"orderBy\":\"startTime\",\"offsetMax\":24,\"offsetMin\":4,\"timeZone\":null,\"showDeleted\":false,\"singleEvents\":true,\"maxResults\":250},\"algolia_search\":{\"enable\":false,\"hits\":{\"per_page\":10},\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"}},\"local_search\":{\"enable\":false,\"trigger\":\"auto\",\"top_n_per_article\":1},\"exturl\":false,\"note\":{\"style\":\"simple\",\"icons\":false,\"border_radius\":3,\"light_bg_offset\":0},\"label\":true,\"tabs\":{\"enable\":true,\"transition\":{\"tabs\":false,\"labels\":true},\"border_radius\":0},\"motion\":{\"enable\":true,\"async\":false,\"transition\":{\"post_block\":\"fadeIn\",\"post_header\":\"slideDownIn\",\"post_body\":\"slideDownIn\",\"coll_header\":\"slideLeftIn\",\"sidebar\":\"slideUpIn\"}},\"fancybox\":true,\"pace\":true,\"pace_theme\":\"pace-theme-minimal\",\"canvas_nest\":false,\"three_waves\":false,\"canvas_lines\":false,\"canvas_sphere\":false,\"canvas_ribbon\":{\"enable\":false,\"size\":300,\"alpha\":0.6,\"zIndex\":-1},\"vendors\":{\"_internal\":\"lib\",\"jquery\":null,\"fancybox\":null,\"fancybox_css\":null,\"fastclick\":null,\"lazyload\":null,\"velocity\":null,\"velocity_ui\":null,\"ua_parser\":null,\"fontawesome\":null,\"algolia_instant_js\":null,\"algolia_instant_css\":null,\"pace\":null,\"pace_css\":null,\"canvas_nest\":null,\"three\":null,\"three_waves\":null,\"canvas_lines\":null,\"canvas_sphere\":null,\"canvas_ribbon\":null,\"han\":null,\"needMoreShare2\":null},\"css\":\"css\",\"js\":\"js\",\"images\":\"images\",\"version\":\"5.1.4\"}"},{"title":"tags","date":"2018-06-27T11:18:10.000Z","updated":"2019-01-08T05:44:21.000Z","comments":true,"path":"tags/index.html","permalink":"https://juanhuang99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"谷歌搜索技巧","slug":"谷歌搜索技巧","date":"2021-11-03T07:11:33.000Z","updated":"2021-11-03T07:35:24.130Z","comments":true,"path":"/blog/2021/11/03/谷歌搜索技巧/","link":"","permalink":"https://juanhuang99.github.io/blog/2021/11/03/谷歌搜索技巧/","excerpt":"谷歌是我们程序员比较常用的搜索工具，因为广告比较少，信息比较准确。不过，有时候我们怎么搜索都找不到我们想到的答案，这时可能就是你关键词给的不对，恰巧，这里有一些实用的技巧分享给你，让你的快速找到你想要的内容。","text":"谷歌是我们程序员比较常用的搜索工具，因为广告比较少，信息比较准确。不过，有时候我们怎么搜索都找不到我们想到的答案，这时可能就是你关键词给的不对，恰巧，这里有一些实用的技巧分享给你，让你的快速找到你想要的内容。 1. 使用引号强制精确匹配如：&quot;what is javascript&quot; 2. 使用 AND 操作符如：html AND css 返回包含两者的搜索结果 3. 使用 OR 操作符如：(javascript OR python) free course 返回包含javascript或者包含python的搜索结果 4. 使用 - 操作符排除如：javascript -css 排除对css的搜索 5. 使用 * 通配符可以使用*通配符作为占位符，它会代替掉任何单词或者短语。 如：&quot;how to start * in 6 months&quot; 6. 单个站点内进行搜索如：site:freecodecamp.org 7. 针对文件类型搜索如：filetype:pdf learn css 8. 搜索数字范围如：ecmascript 2020..2021","categories":[],"tags":[]},{"title":"JavaScript 类型转换","slug":"JavaScript-类型转换","date":"2019-09-06T06:52:01.000Z","updated":"2019-09-16T07:45:30.000Z","comments":true,"path":"/blog/2019/09/06/JavaScript-类型转换/","link":"","permalink":"https://juanhuang99.github.io/blog/2019/09/06/JavaScript-类型转换/","excerpt":"什么是ToPrimitive抽象操作该操作主要是将对象类型转换为基本类型。","text":"什么是ToPrimitive抽象操作该操作主要是将对象类型转换为基本类型。 ToPrimitive(obj,preferredType)JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个preferredType为希望转换成的类型（默认为空，接受的值为Number或String） 在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执行过程如下： 如果obj为原始值，直接返回； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则抛异常。 如果preferredType为String，将上面的第2步和第3步调换，即： 如果obj为原始值，直接返回； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则抛异常。 什么是封装对象var a = new String(‘abc’)，a被叫做封装了基本类型的封装对象，还原一个封装对象的值，可以调用valueOf方法。 显式强制类型转换转换为字符串1.null转换为’null’,undefined转换为’undefined’,其他基本类型都调用基本类型的包装对象属性toString()并返回值。123456const a = 123;const _a = new Number(123);console.log(String(a), _a.toString());//&apos;123&apos; &apos;123&apos;const b = true;const _b = new Boolean(true);console.log(String(b), _b.toString());//&apos;true&apos; &apos;true&apos; 2.数字的字符串化遵循通用规则，但是极小极大数字使用指数形式12const a = 1.07*1000*1000*1000*1000*1000*1000*1000;console.log(String(a));//&apos;1.07e+21&apos; 3.对于普通对象来说，除非自行定义，否则toString()返回Object.prototype.toString()的值,其他对象有自己的toString()方法则调用自己的该方法，但是如果 toString 返回的不是基本类型值，转换时会报 TypeError。12const b = &#123;&#125;;console.log(String(b));//[object object] 4.数组的默认toString()方法进行了重新定义，将所有单元字符串化以后再用‘,’连接起来12const a = [1, 2, 3];console.log(String(a));//&apos;1,2,3&apos; 转换为数字1.true转换为1，false转换为0，undefined转换为NaN，null转换为01234console.log(Number(null));//0console.log(Number(undefined));//NaNconsole.log(Number(true));//1console.log(Number(false));//0 2.对字符串的处理遵循数字常量的相关规定/语法，处理失败时返回NaN123456console.log(Number(&apos;123&apos;));//123console.log(Number(&apos;0b111&apos;));//7console.log(Number(&apos;0o123&apos;));//83console.log(Number(&apos;0x123&apos;));//291console.log(Number(&apos;123a&apos;));//NaNconsole.log(Number(&apos;a123&apos;));//NaN 3.对象（包括数组）会首先按照ToPrimitive抽象操作被转换为相应的基本类型值，再按照前两条规则处理；如果某个对象即不存在valueOf方法也不存在toString方法，则会产生TypeError错误（例如Object.create(null)不存在以上两种方法） 1234567891011121314151617181920212223242526272829303132333435//obj1,obj2分别调用toString和valueOf方法，obj3调用原型上的toString()方法const arr = [1, 2, 3];console.log(Number(arr));//NaNconsole.log(Number(arr.toString()));//NaNconst num = new Number(123);console.log(Number(num));//123console.log(Number(num.valueOf()));//123const bool = new Boolean(true);console.log(bool.valueOf());//trueconsole.log(Number(bool));//1console.log(Number(bool.valueOf()));//1const obj1 = &#123; toString:()=&gt;&quot;21&quot;&#125;const obj2 = &#123; valueOf:()=&gt;&quot;42&quot;, toString:()=&gt;&quot;21&quot;&#125;const obj3 = &#123; a:1&#125;console.log(Number(obj1));//21console.log(Number(obj2));//42console.log(obj3.toString());//[object Object]console.log(Number(obj3));//NaNconst obj = Object.create(null);console.log(Number(obj));//TypeError 转换为布尔值 可以被转换为false的值（undefined，null，false， +0、-0和NaN，’’） 除条件1的其他都被转换为true（切记：封装对象均被转为true） 隐式强制类型转换转换为字符串一元运算符加号（+）首先把非基本类型通过ToPrimitive抽象操作转换为基本类型，如果加号中的两项有一项是字符串，另一项则进行ToString操作。123console.log([1, 2] + [1, 2]); //1,21,2//等同于console.log([1, 2].toString() + [1, 2].toString()); //1,21,2 转换为数字通过一元运算符-、/、*转换，常见的转换方法：12345678910111213+ &apos;2&apos; // 2&apos;2&apos; - 0 // 2&apos;2&apos; / 1 // 2&apos;2&apos; * 1 // 2+ &apos;x&apos; // NaN&apos;x&apos; - 0 // NaN&apos;x&apos; / 1 // NaN&apos;x&apos; * 1 // NaN1 + &apos;2&apos; // &apos;12&apos;1 + + &apos;2&apos; // 3 即：1 + (+ &apos;2&apos;) 转换为布尔值 if(..)语句中的条件判断表达式 for(..;..;..)语句的第二个条件判断表达式 while(..)和do..while(..)的条件判断表达式 ?:中的条件判断表达式 逻辑运算符||和&amp;&amp;左边的操作数（a||b等同于a?a:b，a&amp;&amp;b等同于a?b:a） == 比较记住以下 5 条规则，任何相等比较都不怕。 1、字符串和数字之间的相等比较字符串先转换为数字，然后再比较。 2、其他类型和布尔类型之间的相等比较布尔类型转换为数字，再进行比较。 3、对象和非对象之间的相等比较对象转换成基本类型值，按转换为数字的流程转换后进行比较。对象转换优先级最高。 4、null 和 undefinednull == undefined， 其他类型和 null 均不相等，undefined 也是如此。 5、特殊情况12NaN == NaN // false-0 == +0 // true 两个对象比较，判断的是两个对象是否指向同一个值。下面是一些看起来“不可思议”的相等比较，是否可以按上面的规则解释清楚？123456789101112&quot;0&quot; == false // true// 第2条规则，false 转换为数字，结果为 0，等式变为 &quot;0&quot; == 0// 两边类型不一致，继续转换，第1条规则，&quot;0&quot; 转换为数字，结果为 0，等式变为 0 == 0false == [] // true// 第3条规则，[] 转换基本类型值，[].toString()，结果为 &quot;&quot;，等式变为 &quot;&quot; == false// 两边类型不一致，继续转换，第2条规则，false 转换为数字，结果为 0，等式变为 &quot;&quot; == 0// 两边类型不一致，继续转换，第1条规则，&quot;&quot; 转换为数字，结果为 0，等式变为 0 == 00 == [] // true// 第3条规则，[] 转换基本类型值，[].toString()，结果为 &quot;&quot;，等式变为 0 == &quot;&quot;// 两边类型不一致，继续转换，第1条规则，&quot;&quot; 转换为数字，结果为 0，等式变为 0 == 0 抽象关系比较关系比较都会转换为 a &lt; b 进行比较，a &gt; b 会被转换成 b &lt; a，a &lt;= b 会被转换成 !(b&lt;a)，a &gt;= b 转换为 !(a&lt;b) 比较规则1.如果双方是其他情况首先调用ToPrimitive转换为基本类型;2.若有一方不是字符串，则将其转换为数字再进行比较；3.若有一方是 NaN，结果总是 false。12345678910null &gt;= 0 // truenull &lt;= 0 // truenull == 0 // flase//按照第二条规则，需要将 null 转换为数字，结果为 0，因此 null &gt;= 0 和 null &lt;= 0 是成立的。但是在相等比较规则中（第 4 条），其他类型和 null 均不相等，因此 null == 0 是不成立的。var obj = &#123;&#125;obj &gt;= 0 // falseobj &lt;= 0 // falseobj == 0 // false//按照第 1 条规则，obj 转换结果为 &quot;[object Object]&quot;，接着按第 2 条规则，&quot;[object Object]&quot; 转换为数字，结果为 NaN，按照第 3 条，无论怎么比较结果都是 false。 参考：JavaScript 类型转换深入理解 JavaScript 的类型转换JavaScript各种蛋疼的类型转换","categories":[],"tags":[]},{"title":"彻底弄懂promise","slug":"彻底弄懂promise","date":"2019-04-12T06:03:25.000Z","updated":"2019-04-12T06:16:08.000Z","comments":true,"path":"/blog/2019/04/12/彻底弄懂promise/","link":"","permalink":"https://juanhuang99.github.io/blog/2019/04/12/彻底弄懂promise/","excerpt":"什么是promisepromise是es6的一个重要特性，用于实现异步。promise对象拥有一个叫做状态的属性，该属性不受外界影响，修改后不能再次变化。而Promise是一个构造函数，可以生成promise对象。","text":"什么是promisepromise是es6的一个重要特性，用于实现异步。promise对象拥有一个叫做状态的属性，该属性不受外界影响，修改后不能再次变化。而Promise是一个构造函数，可以生成promise对象。 常见用法：123456789101112var a = new Promise(function (res, rej) &#123; console.log(&apos;1&apos;) if (1) &#123; res(3) &#125; else &#123; rej() &#125;&#125;)a.then(function (val) &#123; console.log(val)&#125;)console.log(2) 输出顺序是1,2,3,为什么呢？Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。因此会马上输出1，而then中的方法是被放到mircotask队列中，在当前的代码执行完后在执行。因此先输出2，再输出3 构造函数的四个方法Promise构造函数上带有resolve，race，all，reject四个方法，他们的共同点是都会返回一个promise。让我们来分别了解下。 resolveresolve接受一个值或是promise对象，如果接受的是promise对象，会直接返回该promise对象，否则返回完成状态的promise对象。123Promise.resolve(3).then(res =&gt; console.log(res))// 3var a = Promise.resolve(3)console.log(Promise.resolve(a) === a) // true reject类似resolve，返回的是拒绝状态的promise all效果：谁跑的慢，以谁为准执行回调Promise.all接受一个数组，分为三种情况: 传入空数组，返回完成状态的promise 传入的数组中没有promise，返回异步完成的prmise 传入的数组中有promise，返回处于pending状态的promise对象，在数组中的promise都成功或者有一个失败时，变成完成状态或拒绝状态 race效果：谁跑的快，以谁为准执行回调同all有点接近，在某个promise完成后，返回该值，根据状态来决定返回的是完成状态还是拒绝状态的promise如果传入的是空数组，返回的promise永远是等待 promise对象的方法promise带有then和catch两个方法 thenthen接受两个参数，返回一个promise。第一个参数是promise在成功的情况下的回调函数，第二个参数是失败情况下的(可选) 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 catch作用和then的第二个参数一样，用来指定reject的回调。还有另外一个作用：在执行resolve的回调（也就是then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。 参考：大白话讲解Promise（一）来聊聊promise","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://juanhuang99.github.io/tags/ES6/"}]},{"title":"exports、module.exports、export、export default的区别","slug":"exports、module.exports、export、export default的区别","date":"2019-01-07T09:22:11.000Z","updated":"2019-04-12T06:10:55.000Z","comments":true,"path":"/blog/2019/01/07/exports、module.exports、export、export default的区别/","link":"","permalink":"https://juanhuang99.github.io/blog/2019/01/07/exports、module.exports、export、export default的区别/","excerpt":"exports、module.exports、export、export default都是模块导出，它们之间又有什么区别，为了不继续混乱下去，是时候把它们的关系捋捋清楚了。","text":"exports、module.exports、export、export default都是模块导出，它们之间又有什么区别，为了不继续混乱下去，是时候把它们的关系捋捋清楚了。 使用范围require: node 和 es6 都支持的引入export / import : 只有es6 支持的导出引入module.exports / exports: 只有 node 支持的导出 node中的模块导入导出exports 和 module.exports在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域。看个代码例子： 123456789101112//utils.jslet a = 100;console.log(module.exports); //能打印出结果为：&#123;&#125;console.log(exports); //能打印出结果为：&#123;&#125;exports.a = 200; //这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : 200&#125;exports = &apos;指向其他内存区&apos;; //这里把exports的指向指走//test.jsvar a = require(&apos;/utils&apos;);console.log(a) // 打印为 &#123;a : 200&#125; 从上面可以看出，其实require导出的内容是module.exports的指向的内存块内容，并不是exports的。他们之间的区别就是exports只辅助module.exports操作内存中的数据，最后真正被require出去的内容还是module.exports。简而言之就是exports 只是 module.exports的引用。 ES6中的模块导入导出export 和 export default它们之间的区别是：1.export与export default均可用于导出常量、函数、文件、模块等2.在一个文件或模块中，export、import可以有多个，export default仅有一个3.通过export方式导出，在导入时要加{ }，export default则不需要4.export能直接导出变量表达式，export default不行。 看个代码例子： 1234567891011121314151617181920//testEs6Export.js&apos;use strict&apos;//导出变量export const a = &apos;100&apos;; //导出方法export const dogSay = function()&#123; console.log(&apos;wang wang&apos;);&#125;//导出方法第二种function catSay()&#123;console.log(&apos;miao miao&apos;); &#125;export &#123; catSay &#125;;//export default导出const m = 100;export default m; //export defult const m = 100;// 这里不能写这种格式。 123456789101112131415161718192021222324//index.js&apos;use strict&apos;var express = require(&apos;express&apos;);var router = express.Router();import &#123; dogSay, catSay &#125; from &apos;./testEs6Export&apos;; //导出了 export 方法 import m from &apos;./testEs6Export&apos;; //导出了 export default import * as testModule from &apos;./testEs6Export&apos;; //as 集合成对象导出/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123;dogSay();catSay();console.log(m);testModule.dogSay();console.log(testModule.m); // undefined , 因为 as 导出是 把 零散的 export 聚集在一起作为一个对象，而export default 是导出为 default属性。console.log(testModule.default); // 100res.send(&apos;恭喜你，成功验证&apos;);&#125;);module.exports = router;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://juanhuang99.github.io/tags/ES6/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://juanhuang99.github.io/tags/nodeJs/"}]},{"title":"hexo的next主题个性化教程","slug":"hexo的next主题个性化教程","date":"2018-06-25T10:51:59.000Z","updated":"2019-01-08T05:47:37.000Z","comments":true,"path":"/blog/2018/06/25/hexo的next主题个性化教程/","link":"","permalink":"https://juanhuang99.github.io/blog/2018/06/25/hexo的next主题个性化教程/","excerpt":"hexo的next主题个性化教程：点击","text":"hexo的next主题个性化教程：点击 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://juanhuang99.github.io/tags/hexo/"}]}]}